


## 相同的前后节点
从头和尾分别开始遍历新旧子节点列表，寻找一样的，如果一样就说明不需要改动

---

**1、纯新增**

旧：1 7 

新：1 5 7 

设置开始指针 j 从 1 开始，发现有一个节点是一样的无需修改

设置尾指针newEnd 与 oldEnd，发现有一个节点7无需修改

这样多出一个5，说明需要新增节点

寻找相同的前置节点的过程如下：
```
第1次：
old
  1       7
  j
  
new
  1       5       7
  j

发现一样，则继续往后走

第2次：
old
  1       7
          j
  
new
  1       5       7
          j

发现不一样，则结束前置相同节点的判断
```

寻找相同的后置节点的过程如下：
```
第1次：
old
  1       7
          j
          oldEnd
  
new
  1       5       7
          j       
                  newEnd

发现是一样的，则这两个end指针继续往前走

第2次：
old
  1       7
          j
  oldEnd
  
new
  1       5       7
          j       
          newEnd

发现不同，则停止
```
由于是考虑纯新增情况，old列表中的节点一定全部会被使用，此时old列表中j > oldEnd

而new列表中
j <= newEnd，
因为要增加的元素如果是一个则相等，如果是多个则j < newEnd

即 j > oldEnd && j <= newEnd

**2、 减少**

旧：1 5 7

新：1 7

设置开始指针 j 从 1 开始，发现有一个节点是一样的无需修改

设置尾指针newEnd 与 oldEnd，发现有一个节点7无需修改

这样少了一个5，说明需要删除多余节点

---

同时需要注意，
第一种情况的j与newEnd直接需要新增的节点可能不止一个，
同理第二种情况需要删除的可能也不止一个

同理可以得到:
j <= oldEnd && j >newEnd


如上两种情况, 较为理想,可以很快处理完新旧节点列表, 只需要增加节点或者删除节点

而实际情况中, 中间部分很有可能较为复杂, 如:
```
old: 1 5 4 2 8 9
new: 1 2 3 4 8 7 9
```

处理完首尾的1 和 9后
```
old: 5 4 2 8 
new: 2 3 4 8 7 
```

要如何继续处理才能保证性能好呢? 这部分便是快速diff的核心

## 最长递增子序列
答案就是最长递增子序列

什么是最长递增子序列? 一个数组的子元素组成, 不能修改出现的顺序, 找到一个最长的子数组, 元素在原数组中可以不是相邻的

例如: 1428的最长递增子序列就是148或者128

那么上一节中的示例:
```
old: 5 4 2 8 
new: 2 3 4 8 7 
```

如何处理呢?

### 多出的删除
```
old: 5 4 2 8 
new: 2 3 4 8 7 
```

可以看到new中不再有5, 则我们需要删除5
```
old: 4 2 8 
new: 2 3 4 8 7 
```

### 少了的补上
```
old: 4 2 8 
new: 2 3 4 8 7 
```
可以看到old中没有new中的3、7，那么我们需要按照出现顺序补上37

但是我们暂时不在这里补，为了操作方便我们后续再补

我们可以暂时忽略3和7：
```
old: 4 2 8 
new: 2 4 8
```

### 乱序的移动到正确顺序上
多出的删除和少了的补上这两步骤都很简单

而较为复杂的就是乱序的，经过前两步骤我们可以将最开始的：
```
old: 5 4 2 8 
new: 2 3 4 8 7 
```

我们到现在这一步可以忽略要删除的和要补上的，便得到了
```
old: 4 2 8 
new: 2 4 8
```

注意我们的步骤是让old经过尽可能少的变化得到new，事实上操作的是old

在这一步中，old与new其实已经一样长了，因为多了的删除、少了的补上，剩下的都是顺序有问题的

我们创建一个与old一样长的数组并将元素初始化为-1, 且这个数组用来记录old中第n个元素应该要移动到哪个位置

```js
/* 这部分代码没有实际运行验证，仅作为原理的理解 */
// oldList与newList即为前面提到的新老节点数组, 我这里只简单示范, 不做具体的赋值, 了解原理即可
const oldList = []
const newList = []

const oldLength = oldList.length;
const source = new Array(oldLength).fill(-1)

// - key: 节点的唯一标识符key
// - value: 节点在newList中的位置
const nodeNewPlaceMap = {};

newList.forEach((node, index) => {
  nodeNewPlaceMap[node.key] = index;
})

// 遍历旧节点数组，判断旧节点数组上的每个元素应该移动到哪个位置
oldList.forEach((item, index) => {
  const oldNodeKey = item.key;
  const newIndex = nodeNewPlaceMap[oldNodeKey];
  source[index] = newIndex;
})

```

此时，对于：
```
old: 4 2 8 
new: 2 4 8
```
我们得到的source数组为：
```
[1, 0, 2]
```

这个数组揭示了从old的第i个元素应该移动到第source[i]的位置就可以得到new

到这里，问题就变成了，如何移动最少次

vue使用了最长递增子序列(LIS)算法来解决这个问题，其核心思想是找到一个最长的递增子序列，递增是为了保证数组有序

这样我们只需要移动其他元素即可

例如：
```
old: 4 2 8 
new: 2 4 8
source = [1, 0, 2]
```

我们可以得到source数组的最长递增子序列为[0, 2] 或者 [1, 2]
我们使用[0, 2]

那么source中只需要移动1，将1移动到0与2之间，问题解决

LIS算法可以自行从网上找

## 其他
vue设计中的快速diff的少的补上，事实上并不是如同我这般忽略，而是与求source中同步解决，也就是没有忽略直接求source

这样遇到少的补上的元素，求source时直接跳过，求完后，仍为-1的元素代表了需要补上的

这里只是为了理解的方便以忽略的形式讲解



